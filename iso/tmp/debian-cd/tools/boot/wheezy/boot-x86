# This script gets sourced from boot-i386 and boot-amd64.
#
# Do install stuff for x86, including making bootable CDs
# Works with debian-installer
#
# $1 is the CD number
# $2 is the temporary CD build dir

. $BASEDIR/tools/boot/$DI_CODENAME/common.sh
. $BASEDIR/tools/boot/$DI_CODENAME/x86-desktop.sh

set -e
#set -x

N=$1
CDDIR=$2
BOOTDIR=
if [ "$DI_WWW_HOME" = "default" ];then

    # Tempting as it might be to merge these two definitions using $ARCH,
    # do *not* do that - these defs are parsed out by other scripts that
    # won't cope with that
	if [ "$ARCH" = i386 ]; then
		DI_WWW_HOME="https://d-i.debian.org/daily-images/i386/daily"
	else
		DI_WWW_HOME="https://d-i.debian.org/daily-images/amd64/daily"
	fi
	if [ -n "$DI_DIR" ];then
		DI_DIR="$DI_DIR/${DI_WWW_HOME#*https://}"
		DI_WWW_HOME=""                     
		echo "Using images from $DI_DIR"
	fi
fi
if [ ! "$DI_DIST" ]; then
	DI_DIST="$DI_CODENAME"
fi

case "$MKISOFS" in
    *xorriso*)
        XORRISO_VER=$(xorriso_version)
        ;;
    *)
	echo "ERROR: debian-cd now depends on xorriso for making x86 bootable CDs."
	exit 1;
	;;
esac

cd $CDDIR/..

# This script is called with $1 (now $N) as the CD to make bootable.
# N may be in the form "n" or "n_NONUS" There may be more than 4
# disks...support extras.

# Strip NONUS part of disk number
# NN will be 1...N so it can be used as an index
NN=`echo $N | sed -e 's/_NONUS//'`

# Exit if this is not a boot disk
if [ $NN != 1 ] ; then exit 0; fi

INSTALLDIR_i386="install.386"
INSTALLDIR_amd64="install.amd"

if [ "$ARCH" = i386 ]; then
	INSTALLDIR="$INSTALLDIR_i386"
else
	INSTALLDIR="$INSTALLDIR_amd64"
fi

BOOT_IMAGES="cdrom/initrd.gz cdrom/vmlinuz cdrom/debian-cd_info.tar.gz"
# Only include disk images on full CDs, not on smaller images.
#if [ "$ARCH" = i386 ] && [ "$INSTALLER_CD" != 1 ] && [ "$INSTALLER_CD" != 2 ] && [ "$INSTALLER_CD" != C ]; then
	#DISK_IMAGES="floppy/cd-drivers.img floppy/boot.img floppy/root.img"
	#EXTRA_DISK_IMAGES="cdrom/boot.img"
#fi

# Download boot images.
for image in $BOOT_IMAGES; do
	if [ ! -e "$image" ]; then
		dir=$(dirname $image)
		mkdir -p $dir
		if [ -n "$LOCAL"  -a -f "${LOCALDEBS:-$MIRROR}/dists/$DI_DIST/local/installer-$ARCH/current/images/$image" ]; then
			cp "${LOCALDEBS:-$MIRROR}/dists/$DI_DIST/local/installer-$ARCH/current/images/$image" "$image"
		elif [ ! "$DI_WWW_HOME" ];then
			if [ ! "$DI_DIR" ];then
				DI_DIR="$MIRROR/dists/$DI_DIST/main/installer-$ARCH/current/images"
			fi
#			echo "Copying images from $DI_DIR"
			cp "$DI_DIR/$image" "$image"
		else
			$WGET "$DI_WWW_HOME/$image" -O "$image"
		fi
	fi
done

# Images that are not really required or may be unavailable.
for image in $DISK_IMAGES $EXTRA_DISK_IMAGES; do
	if [ ! -e "$image" ]; then
		dir=$(dirname $image)
		mkdir -p $dir
		if [ -n "$LOCAL"  -a -f "${LOCALDEBS:-$MIRROR}/dists/$DI_DIST/local/installer-$ARCH/current/images/$image" ]; then
			cp "${LOCALDEBS:-$MIRROR}/dists/$DI_DIST/local/installer-$ARCH/current/images/$image" "$image"
		elif [ ! "$DI_WWW_HOME" ];then
			if [ ! "$DI_DIR" ];then
				DI_DIR="$MIRROR/dists/$DI_DIST/main/installer-$ARCH/current/images"
			fi
			cp "$DI_DIR/$image" "$image" || true
		else
			$WGET "$DI_WWW_HOME/$image" -O "$image" || rm -f "$image"
		fi
	fi
done

# Only disk one gets the extra files installed
if [ "$NN" = "1" ]; then
	# populate the install directory as well
	for disk in $DISK_IMAGES $EXTRA_DISK_IMAGES; do
		if [ -e "$disk" ]; then
			dir=$(dirname $disk)
			mkdir -p $CDDIR/$INSTALLDIR/$dir
			cp -lf $disk $CDDIR/$INSTALLDIR/$dir
		fi
	done

	if [ -e "$MIRROR/tools" ] && \
	   [ ! -e $CDDIR/tools ] && \
	   [ "$OMIT_DOC_TOOLS" != "1" ] ; then
		echo "  Adding tools to CD1"
		$BASEDIR/tools/add_files $CDDIR $MIRROR tools
		# Remove the win32-loader/ subdirectory from tools, as d-i already installs setup.exe
		rm -Rf $CDDIR/tools/win32-loader
	fi
fi

extra_image () {
	image=$1
	doppelgangers="$2"
	dir=$(dirname "$image")

	mkdir -p $CDDIR/$INSTALLDIR/$dir
	if [ ! -e $CDDIR/$INSTALLDIR/"$image" ] ; then
		if [ ! "$DI_WWW_HOME" ] ; then
			if [ ! "$DI_DIR" ] ; then
				DI_DIR="$MIRROR/dists/$DI_DIST/main/installer-$ARCH/current/images"
			fi
			cp "$DI_DIR/cdrom/$image" $CDDIR/$INSTALLDIR/"$image"
		else
			$WGET "$DI_WWW_HOME/cdrom/$image" -O $CDDIR/$INSTALLDIR/"$image"
		fi
	fi
	for doppelganger in $doppelgangers ; do
		if [ -f "$CDDIR/$INSTALLDIR/$dir/$doppelganger" ] &&
			cmp -s $CDDIR/$INSTALLDIR/"$image" $CDDIR/$INSTALLDIR/"$dir"/"$doppelganger" ; then
			echo "  $image identical to $doppelganger. Linking"
			ln -nf $CDDIR/$INSTALLDIR/"$dir"/"$doppelganger" $CDDIR/$INSTALLDIR/"$image"
			break
		fi
	done
}

# If multiple desktops are to be supported, set the default one
ORIG_DESKTOP=
case "$DESKTOP" in
    gnome)
	# gnome is default in tasksel 
	DESKTOP=
	;;
    all)
	ORIG_DESKTOP=$DESKTOP
	DESKTOP=
	;;
    light)
	ORIG_DESKTOP=$DESKTOP
	DESKTOP=xfce
	;;
esac
# desktop boot parameter gets set separately through DESKTOP variable
KERNEL_PARAMS="$(echo "$KERNEL_PARAMS" | sed -r "s/desktop=[^ ]* ?//")"

echo "  Using ISOLINUX boot-disks image on CD$N"
mkdir -p $CDDIR/$INSTALLDIR
cp -lf cdrom/vmlinuz $CDDIR/$INSTALLDIR/
cp -lf cdrom/initrd.gz $CDDIR/$INSTALLDIR/
if [ -e $CDDIR/tools/loadlin.exe ]; then
	echo "\\tools\\loadlin.exe vmlinuz initrd=initrd.gz" | todos > $CDDIR/$INSTALLDIR/install.bat
fi

mkdir -p $CDDIR/../syslinux
SYSLINUXDEB=$(find_pkg_file syslinux)
if [ -z "$SYSLINUXDEB" ]; then
	echo "ERROR: syslinux package is required" >&2
	exit 1
fi
(dpkg --fsys-tarfile "$MIRROR/$SYSLINUXDEB" | \
	tar xf - -C $CDDIR/../syslinux ./usr/lib)

if [ -n "$ARCHIVE_EXTRACTED_SOURCES" ]; then
	echo $SYSLINUXDEB >> $CDDIR/../$N.pkgs_extracted
	find_pkg_file syslinux source >> $CDDIR/../$N.pkgs_extracted
fi

add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-isohybrid-mbr syslinux/usr/lib/syslinux/isohdpfx.bin"

# In case of a multi-arch CD the script will be called two times. The
# first time the isolinux dir gets set up for single arch; if it is
# called a second time the isolinux dir already exists and we know it
# will be multi-arch. We then throw away the first version and just
# configure things from scratch for multi-arch.

MULTIARCH=
if [ -e boot$N/isolinux/isolinux.cfg ]; then
	MULTIARCH=1
	rm -r boot$N/isolinux
fi

mkdir -p boot$N/isolinux
# Isolinux setup including config and help files comes from d-i.
cat cdrom/debian-cd_info.tar.gz | (cd boot$N/isolinux/; tar zx)

# If we don't have grub stuff from d-i, tell xorriso to add a
# partition offset for the isohybrid code
if [ ! -d boot$N/isolinux/grub ] ; then
    add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-partition_offset 16"
fi

di_syslinux_ver="$(di_syslinux_version)"
case "$di_syslinux_ver" in
	2.0)
		: ;;
	1.*)
		echo "Error: syslinux config versions before 2.0 are not supported"
		exit 1 ;;
	*)
		echo "Error: unrecognized syslinux config version '$di_syslinux_ver'"
		exit 1 ;;
esac

# Not everything in the tarball is isolinux stuff
if [ -e boot$N/isolinux/win32-loader.ini ] ; then
	for file in boot$N/isolinux/g2ldr* boot$N/isolinux/setup.exe boot$N/isolinux/win32-loader.ini; do
		if [ -e $file ] ; then
			mv -v $file boot$N/
		fi
	done
fi

if [ -e boot$N/isolinux/f3.txt.withgtk ]; then
	extra_image gtk/vmlinuz         "../vmlinuz"
	extra_image gtk/initrd.gz       "../initrd.gz"
	mv boot$N/isolinux/f3.txt.withgtk boot$N/isolinux/f3.txt
	mv boot$N/isolinux/f4.txt.withgtk boot$N/isolinux/f4.txt
	if [ -e boot$N/isolinux/isolinux.cfg.withgtk ]; then
		mv boot$N/isolinux/isolinux.cfg.withgtk boot$N/isolinux/isolinux.cfg
	fi
	if [ -e $CDDIR/tools/loadlin.exe ]; then
		echo "\\tools\\loadlin.exe \\$INSTALLDIR\\vmlinuz initrd=initrd.gz vga=788" | todos > $CDDIR/$INSTALLDIR/gtk/install.bat
	fi
fi
rm -f boot$N/isolinux/isolinux.cfg.with*

if variant_enabled "xen" ; then
	extra_image xen/vmlinuz         "../vmlinuz   ../gtk/vmlinuz"
	extra_image xen/initrd.gz       "../initrd.gz ../gtk/initrd.gz"
	extra_image xen/debian.cfg || extra_image xen/xm-debian.cfg
fi

# Modify win32-loader.ini for the "current" arch
if [ -e boot$N/win32-loader.ini ]; then
	sed -i "s|install/|$INSTALLDIR/|" boot$N/win32-loader.ini
	if [ "${DESKTOP}" ] ; then
		sed -i "s|^\(default_desktop\)=.*|\1=${DESKTOP}|" boot$N/win32-loader.ini
	fi
fi

cp -f $CDDIR/../syslinux/usr/lib/syslinux/isolinux.bin boot$N/isolinux/
cp -f $CDDIR/../syslinux/usr/lib/syslinux/vesamenu.c32 boot$N/isolinux/
if [ -e $CDDIR/../syslinux/usr/lib/syslinux/ldlinux.c32 ]; then
	cp -f $CDDIR/../syslinux/usr/lib/syslinux/ldlinux.c32 boot$N/isolinux/
	cp -f $CDDIR/../syslinux/usr/lib/syslinux/libcom32.c32 boot$N/isolinux/
	cp -f $CDDIR/../syslinux/usr/lib/syslinux/libutil.c32 boot$N/isolinux/
fi

if [ -z "$MULTIARCH" ]; then
	# Set up isolinux dir for only the current arch
	grep -lr '%install%' boot$N/isolinux/* | xargs -r sed -i "s|%install%|$INSTALLDIR|"
    
	# Remove the amd*.cfg files to avoid them being loaded on a
	# disc that does not have both amd64 and i386 dirs.
	find boot$N/isolinux/ -name "amd*.cfg" -delete
else
	# Set up isolinux dir for multi-arch
	grep -lr '%install[-amd]*%' boot$N/isolinux/* | xargs -r sed -i -e "s|%install%|$INSTALLDIR_i386|" -e "s|%install-amd%|$INSTALLDIR_amd64|"

	for file in boot$N/isolinux/f3.txt* boot$N/isolinux/f4.txt*; do
		sed -i "4 s/^$/(note: i386 is default; prepend 'amd64-' to use an amd64 kernel instead)/" $file
	done

	if [ -e boot$N/win32-loader.ini ]; then
		# Modify win32-loader.ini to also cover the "other" arch
		if [ "$ARCH" = i386 ]; then
			sed -i -e "/^arch=/d
					   /^i386\//p; s/^i386/amd64/; s/=$INSTALLDIR_i386/=$INSTALLDIR_amd64/g" \
					       boot$N/win32-loader.ini
		else
			sed -i -e "/^arch=/d
					   /^amd64\//p; s/^amd64/i386/; s/=$INSTALLDIR_amd64/=$INSTALLDIR_i386/g" \
					       boot$N/win32-loader.ini
		fi
	fi

	# Apply workaround for #505243
	multiarch_workaround
fi

if [ "$SPLASHPNG" ] ; then
	# Insert our own splash screen.  Color index 0 is background, and
	# index 7 is foreground.  Set to black and white respecively
	pngtopnm < $SPLASHPNG | ppmquant 16 | \
		ppmtolss16 "#ffffff=7" "#000000=0" > boot$N/isolinux/splash.rle
	pngtopnm < $SPLASHPNG | ppmquant 16 | pnmtopng  > boot$N/isolinux/splash.png
fi

# used by Debian Edu
if [ "$LOGOPNG" ] ; then
	# Add custom logo to the initrd.gz file, replacing old image
	GTKINITRD=$CDDIR/$INSTALLDIR/gtk/initrd
	GTKINITRDGZ=$GTKINITRD.gz
	echo "info: Adding $LOGOPNG to $GTKINITRD"
	INITRDDIR=$TDIR/initrd-$$
	# Repack initrd with new image
	mkdir -p $INITRDDIR
	(
		cd $INITRDDIR
		gunzip $GTKINITRDGZ
		mkdir -p $INITRDDIR/usr/share/graphics
		cp $LOGOPNG $INITRDDIR/usr/share/graphics/logo_debian.png
		echo usr/share/graphics/logo_debian.png | \
		cpio -oA -H newc -F $GTKINITRD
		gzip -9 $GTKINITRD
	)
	rm -rf $INITRDDIR
fi

sed -i "s|built on|built $BUILD_DATE; d-i|" boot$N/isolinux/f1.txt

if [ -n "$KERNEL_PARAMS" ]; then
	# Substitute custom kernel params into the isolinux config file(s)
	for file in boot$N/isolinux/*.cfg boot$N/isolinux/desktop/*.cfg; do
		case "$(basename $file)" in
			instsel.cfg)
				continue ;;
		esac
		sed -i "/^[[:space:]]\+append .*--/ s|append|append $KERNEL_PARAMS|" \
			$file
	done
fi

case "$ORIG_DESKTOP" in
	all)
		modify_for_all_desktop ;;
	light)
		modify_for_light_desktop ;;
	*)
		modify_for_single_desktop ;;
esac

# Add autorun
if [ -f boot$N/setup.exe ]; then
# when win32-loader is present, use that (it already checks for README.html)
	todos > $CDDIR/autorun.inf <<EOF
[autorun]
open=setup.exe
icon=setup.exe,0
label=Install Debian GNU/Linux

[Content]
MusicFiles=false
PictureFiles=false
VideoFiles=false
EOF
elif [ -f $CDDIR/README.html ]; then
	todos > $CDDIR/autorun.inf <<EOF
[autorun]
open=autorun.bat
label=Install Debian GNU/Linux

[Content]
MusicFiles=false
PictureFiles=false
VideoFiles=false
EOF
	todos > $CDDIR/autorun.bat <<EOF
@echo Starting "README.html"...
@start README.html
@exit
EOF
fi

rm -rf cdrom floppy

# Common mkisofs options when creating CDs
add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-J -joliet-long"
add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-cache-inodes"

# Add the normal options to make an ElTorito bootable CD/DVD
add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-b isolinux/isolinux.bin"
add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-c isolinux/boot.cat"
add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-no-emul-boot"
bls=4 # Specify 4 for BIOS boot, don't calculate it
add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-boot-load-size $bls"
add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-boot-info-table"	

# We explicitly put the boot bits in boot$N (as opposed to CD$N) and
# list it first on the eventual mkisofs command line. That means
# they'll be placed nearer the front of the eventual image; some older
# BIOSes apparently have a limitation on what they'll boot here.
add_mkisofs_opt $CDDIR/../$N.mkisofs_dirs "boot$N"

if [ -d boot$N/isolinux/grub ] ; then
    echo "  Adding EFI boot code for $ARCH on CD$N"

    # Move GRUB files to the right place.
    mkdir -p $CDDIR/efi/boot
    mcopy -i boot$N/isolinux/grub/efi.img ::efi/boot/bootx64.efi $CDDIR/efi/boot/bootx64.efi
    mkdir -p $CDDIR/boot/grub
    mv boot$N/isolinux/grub/* $CDDIR/boot/grub/
    rmdir boot$N/isolinux/grub

    # Create grub menu entries to match the isolinux ones
    sed -i '/^menuentry/Q' $CDDIR/boot/grub/grub.cfg;
    $BASEDIR/tools/boot/$DI_CODENAME/parse_isolinux \
        boot$N/isolinux $CDDIR $BASEDIR/data/$DI_CODENAME/grub-theme.in "$DISKINFO_DISTRO" "$DEBIAN_KERNEL" "$DEBVERSION" \
        >> $CDDIR/boot/grub/grub.cfg

    # Stuff the EFI boot files into a FAT filesystem, making it as
    # small as possible.

    sector_bytes=512 # -S
    cluster_sectors=4 # -s
    cluster_bytes=$((sector_bytes * cluster_sectors))

    clusters=2 # 1 cluster for each sub-directory
    for file in $CDDIR/efi/boot/boot*.efi; do
        [ -f "$file" ] || continue
        clusters=$(($clusters + (($(stat -c %s "$file") + $cluster_bytes - 1) / $cluster_bytes)))
    done
    reserved_sectors=1 # boot-sector -R
    reserved_bytes=$(($reserved_sectors * $sector_bytes))
    fat_copies=2 # -f
    if [ "$clusters" -le $(((1 << 12) - 2)) ]; then
        fat_entry_bytes=3/2 # -F
    elif [ "$clusters" -le $(((1 << 16) - 2)) ]; then
        fat_entry_bytes=2 # -F
    else
        fat_entry_bytes=4 # -F
    fi
    fat_bytes=$((($clusters * $fat_entry_bytes + $sector_bytes - 1) / $sector_bytes * $sector_bytes))
    root_entries=512 # -r
    root_entry_bytes=32
    root_bytes=$(($root_entries * root_entry_bytes))
    size=$(($reserved_bytes + $fat_copies * $fat_bytes + $root_bytes + $clusters * $cluster_bytes))

    track_sectors=32
    track_bytes=$((sector_bytes * $track_sectors))
    tracks=$((($size + $track_bytes - 1) / $track_bytes))
    block_bytes=1024
    blocks=$(($tracks * $track_bytes / $block_bytes))

    rm -f $CDDIR/boot/grub/efi.img
    mkfs.msdos -C "$CDDIR/boot/grub/efi.img" $blocks >/dev/null
    mmd -i "$CDDIR/boot/grub/efi.img" ::efi
    mmd -i "$CDDIR/boot/grub/efi.img" ::efi/boot
    mcopy -i "$CDDIR/boot/grub/efi.img" $CDDIR/efi/boot/boot*.efi \
        "::efi/boot"

    # Ugh - different code here depending on the version of xorriso we've got
    if [ $XORRISO_VER -le 10202 ] ; then
        # 1.2.2 shipping in Wheezy
        echo "Using older EFI command line for xorriso $XORRISO_VER"
        # Tell xorriso to create a secondary ElTorito boot record for the
        # EFI bootloader
        add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-eltorito-alt-boot --efi-boot boot/grub/efi.img"
        # Add the efi image as a FAT partition too, so our CD image will
        # also boot on a USB key (like isohybrid, just implemented
        # differently)
        add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-append_partition 2 0x01 $CDDIR/boot/grub/efi.img"

    elif [ $XORRISO_VER -gt 10202 ] ; then
        echo "Using newer EFI support in xorriso $XORRISO_VER"
        add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot"
        add_mkisofs_opt $CDDIR/../$N.mkisofs_opts "-isohybrid-gpt-basdat -isohybrid-apm-hfsplus"
    fi	
else
    echo "  No EFI boot code for $ARCH on CD$N"
fi

# th,th, thats all

