#!/usr/bin/perl -w
# Generate a list of packages required for debian-installer
# This script makes use of the following variables that need to be preset:
# MIRROR, DI_CODENAME, BASEDIR
die "Missing \$MIRROR variable" unless $ENV{MIRROR};
die "Missing \$DI_CODENAME variable" unless $ENV{DI_CODENAME};
die "Missing \$BASEDIR variable" unless $ENV{BASEDIR};
die "Missing \$ARCHES variable" unless $ENV{ARCHES};

# Early exit if we're building a source-only CD
exit 0 if $ENV{ARCHES} =~ /^\s*source\s*$/;

my @ARCHES;
if ( $ENV{ARCHES} ) {
    push @ARCHES, 'i386' if $ENV{ARCHES} =~ /(^|\s)i386(\s|$)/;
    push @ARCHES, 'amd64' if $ENV{ARCHES} =~ /(^|\s)amd64(\s|$)/;
    push @ARCHES, grep { !/^(source|i386|amd64)$/ } split /\s+/, $ENV{ARCHES};
}
@ARCHES = qw{i386 amd64} unless @ARCHES;

my @VARIANTS;
if ( $ENV{VARIANTS} ) {
    @VARIANTS = split(" ", $ENV{VARIANTS});
}

my $DATE=`date`;
chomp $DATE;
open(OUT, ">debian-installer") || die "write: $!";
print OUT << "EOF";
/* List of udebs to be included so that debian-installer works fine 
 *
 * This list can be generated with the command:
 * ../tools/generate_di_list
 *
 * DO NOT EDIT THIS FILE, edit the above script
 *
 * Last update: $DATE
 */
EOF

my @common_excludes = read_exclude("exclude-udebs");
my $mirror_path = "$ENV{MIRROR}/dists/$ENV{DI_CODENAME}";
my @components = qw(main);
push @components, 'contrib' if $ENV{CONTRIB};
push @components, 'non-free' if $ENV{NONFREE};
push @components, 'local' if $ENV{LOCAL};

foreach my $arch (@ARCHES) {
	(my $cpparch = $arch) =~ s/-/_/g;
    my $output = '';
    for my $component ( @components ) {
        my $pgz="$mirror_path/$component/debian-installer/binary-$arch/Packages.gz";
        my $pxz="$mirror_path/$component/debian-installer/binary-$arch/Packages.xz";
        if ( $component eq 'local' and $ENV{LOCALDEBS} ) {
            $pgz="$ENV{LOCALDEBS}/dists/$ENV{DI_CODENAME}/local/debian-installer/binary-$arch/Packages.gz";
            $pxz="$ENV{LOCALDEBS}/dists/$ENV{DI_CODENAME}/local/debian-installer/binary-$arch/Packages.xz";
        }

        my @exclude = @common_excludes;
        push @exclude, read_exclude("exclude-udebs-$arch")
            if -e exclude_path("exclude-udebs-$arch");

	if (-f $pgz) {
	    foreach my $udeb (map { chomp; $_ } `zcat $pgz | awk '/^Package:/ {print \$2}'`) {
		$output .= "$udeb\n" unless grep { $udeb =~ /^${_}$/ } @exclude;
	    }
	} elsif (-f $pxz) {
	    foreach my $udeb (map { chomp; $_ } `xzcat $pxz | awk '/^Package:/ {print \$2}'`) {
		$output .= "$udeb\n" unless grep { $udeb =~ /^${_}$/ } @exclude;
	    }
	} else {
            print "Missing package file for $arch/$component.\n";
            next;
        }
    }

    next unless $output;
    print OUT "#ifdef ARCH_$cpparch\n";
    print OUT $output;
    print OUT "#endif /* ARCH_$cpparch */\n";
}

sub read_exclude {
	my $file=exclude_path(shift);
    unless ( open (IN, "<$file") ) {
       warn "failed to read exclude file $file";
       return;
    }
	my @ret;
	while (<IN>) {
		chomp;
		s/^#.*//;
		next unless length;
		my ($pkg,@cond) = split(" ", $_);
		my $skip = 0;
		foreach my $cond ( @cond ) {
		    if ($cond =~ /^!(.*)/) {
			$skip = 1 if grep { $_ eq $1 } @VARIANTS;
		    } else {
			$skip = 1 unless grep { $_ eq $cond } @VARIANTS;
		    }
		}
		next if $skip;
		$pkg=quotemeta($pkg);
		$pkg=~s/\\\*/.*/g;
		push @ret, $pkg;
	}
	close IN;
	return @ret;
}

sub exclude_path {
	my $file=shift;
	return "$ENV{BASEDIR}/data/$ENV{DI_CODENAME}/$file";
}
